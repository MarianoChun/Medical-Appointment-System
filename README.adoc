= Bases de Datos I: Trabajo Práctico
Agustín Lautaro Escobar <agustinesco@outlook.es>; Francisco Ruiz <franciscoruizlezcano@gmail.com>; Mariano Chun <marianochun01@gmail.com> v1, {docdate}. Docentes Daniel Bertaccini y Hernán Rondelli
:title-page:
:numbered:
:source-highlighter: coderay
:tabsize: 4

== Introducción
El objetivo del proyecto es desarrollar un sistema de administración de turnos médicos que permita asignar turnos correctamente, mantener la información de los pacientes, registrar las atenciones realizadas, administrar las liquidaciones mensuales de los médicos y enviar notificaciones por correo electrónico a los pacientes en diferentes situaciones (reserva de turno, cancelación, recordatorio, pérdida de turno). Además, se requiere la creación de la base de datos relacional con tablas específicas y la implementación de stored procedures y triggers para la lógica del sistema. También se solicita la comparación del modelo relacional con un modelo NoSQL, utilizando la base de datos BoltDB y almacenando los datos en formato JSON. El proyecto deberá poder ejecutarse desde una aplicación CLI escrita en Go.

== Descripción

=== Decisiones de diseño
Debido a que eramos varios personas desarrollando al mismo tiempo, decidimos utilizar una división de tareas y estructura de proyecto. Gracias a ello logramos una mejor organización y comunicación entre los miembros del equipo. Por otra parte, gracias a la lectura del contenido de archivos que nos provee el lenguaje, pudimos implementar toda la creación de bases de datos, datos, primary keys, foreign keys, stored procedures y triggers mediante archivos `.sql`. Esto nos permitió una mejor organización y mantenimiento de la base de datos.

=== Problemas encontrados
Durante el desarrollo del proyecto nos encontramos con varios problemas:

1. Para contextualizar mejor el dominio del problema que presenta el proyecto, realizamos un diagrama de Modelo Relacional, de tal forma de poder identificar correctamente las
relaciones entre las tablas y tener una idea de su cardinalidad.

2. Con el fin de popular las tablas de la base de datos, tuvimos que utlizar la herramienta https://www.mockaroo.com/[mockaroo] para generar datos aleatorios.

3. Encontramos un desafío al desarrollar los procedimientos almacenados para la generación de turnos disponibles y el envío de correos electrónicos. En una primera iteración, intentamos utilizar el método max(id) para obtener el valor máximo del identificador y luego sumarle 1. Sin embargo, decidimos cambiar nuestra aproximación y optamos por utilizar el tipo de datos serial para los identificadores de las tablas pertinentes.

4. Para inicializar la creación de la base de datos y su esquema pertinente, tuvimos que realizar dos conexiones a PostreSQL. La primera conexión se utilizó para crear la base de datos y la segunda para crear el esquema. Esto se debió a que en una misma conexión no encontramos la posibilidad de cambiar de esquema.

5. A la hora de leer los archivos `.sql`, tuvimos inconvenientes con la lectura de los caracteres especiales y comentarios. Para solucionar este problema, utilizamos las funciones utilitarias de `kit/queries.go` para sanitizar el contenido de los scripts.

== Implementación

=== Estructura del proyecto
La estructuración del proyecto la consideramos esencial para organizar, planificar y desarrollar eficientemente la aplicación. Nos proporciona claridad, mejora la colaboración y la comunicación entre los miembros del equipo.

A continuación se muestra la estructura del proyecto:
[source, bash]
----
.
├── cmd
│   └── cli
├── internal
│   ├── db
│   ├── fk
│   ├── pk
│   ├── fk
│   ├── sp
│   ├── trigger
│   ├── appointment.go
│   ├── consultingroom.go
│   ├── insurance.go
│   └── patient.go
├── kit
├── nosql
├── sql
│   ├── data
│   ├── fk
│   ├── pk
│   ├── sp
│   ├── triggers
│   ├── schema.sql
│   └── database.sql
├── go.mod
└── go.sum
----

===== `/cmd`
Contiene todos los puntos de entrada e interacciones con el usuario de nuestra aplicación.

===== `/internal`
Contiene todos los componentes que consideramos core de nuestra aplicación.

===== `/kit`:
Se encuentran funciones útiles que utilizamos en cualquier parte de la aplicación.

===== `/nosql`
Contiene los archivos necesarios para la gestión de la base de datos no relacional.

===== `/sql`
Contiene los archivos `.sql` necesarios para la creación de la base de datos, datos pre insertados, primary key, foreign key, stored procedures y triggers.

===== Comandos
Para ejecutar la aplicación CLI, se debe ejecutar el siguiente comando: `go run cmd/cli/main.go`

=== SQL
==== DDL
===== Creación de la BDD y esquema
* Script de creación de la BDD, ubicado en `sql/database.sql`

* Script de creación del esquema de la BDD, ubicado en `sql/schema.sql`

===== Primary Keys
* Script de creación de las PKs, ubicado en `sql/pk/create.sql`

* Script de eliminación de las PKs, ubicado en `sql/pk/remove.sql`

===== Foreign Keys
* Script de creación ubicado en `sql/fk/create.sql`

* Script de eliminación ubicado en `sql/fk/remove.sql`

==== DML
===== Inserción de datos
* Script para las obras sociales ubicado en `sql/data/1-obra_social.sql`

* Script para los mediques ubicado en `sql/data/2-medique.sql`

* Script para las cobertura ubicado en `sql/data/3-cobertura.sql`

* Script para los consultorios ubicado en `sql/data/4-consultorio.sql`

* Script para las agendas ubicado en `sql/data/5-agendas.sql`

* Script para los pacientes ubicado en `sql/data/6-paciente.sql`

* Script para las solicitudes de reservas ubicado en `sql/data/6-solicitud_reservas.sql`

==== Diagrama del modelo relacional
.Diagrama del Modelo Relacional
image::docs/images/diagram.png[]

==== Transacciones
Durante el desarrollo del trabajo práctico, eramos conscientes que las transacciones eran fundamentales para garantizar la integridad y la consistencia de los datos, preveniniendo los conflictos de concurrencia y asegurar que los cambios realizados en la base de datos sean duraderos.

Por esto último, consideramos pertienente ejecutar cada proceso importante que iteracciona con la base de datos dentro de una transacción.

En contraparte, como indicamos en la sección de problemas encontrados, no pudimos indicar el isolation level dentro de cada stored procedure. Por lo que decidimos indicarlo al inicio de cada transacción mediante codigo. Por ejemplo:

[source, go]
----
// Inicio de la transacción
begin, err := s.db.App().Begin()
if err != nil {
	return err
}

// Indicamos el isolation level
_, err = begin.Exec("set transaction isolation level serializable;")
if err != nil {
	log.Fatal(err)
	// Rollback en caso de error
	begin.Rollback()
	return err
}

// Ejecutamos el statement o stored procedure
_, err = begin.Exec(statement)
if err != nil {
	log.Fatal(err)
	// Rollback en caso de error
	begin.Rollback()
	return err
}

// Commit de la transacción
begin.Commit()
----

==== Stored Procedures

===== Atender turno
* *Ubicación*: `sql/sp/attend_appointment.sql`
* *Descripción del proceso*: El procedimiento almacenado "attend_appointment" se encarga de atender una cita específica identificada por su número de turno. El proceso consta de los siguientes pasos:

1. Seleccionar los datos del turno correspondiente al número de turno proporcionado.

2. Verificar si se encontró un turno con el número proporcionado. Si no se encuentra, se registra un error indicando que el número de turno no es válido y se devuelve "false".

3. Comprobar si la fecha del turno coincide con la fecha actual. Si no coinciden, se registra un error indicando que el turno no corresponde a la fecha del día y se devuelve "false".

4. Verificar si el estado del turno es "reservado". Si no lo está, se registra un error indicando que el turno no está reservado y se devuelve "false".

5. Si todas las verificaciones anteriores son exitosas, se actualiza el estado del turno a "atendido".

6. Se devuelve "true" para indicar que el proceso de atención de la cita se ha completado con éxito.

En resumen, este procedimiento almacenado garantiza que solo se puedan atender citas válidas y reservadas en la fecha actual. Si se cumplen todas las condiciones, el estado del turno se actualiza y se devuelve un valor booleano para indicar el éxito del proceso. En caso de que alguna condición no se cumpla, se registra un error correspondiente y se devuelve un valor booleano para indicar el fallo del proceso.

* *Isolation level utilizado*: El isolation level utilizado es "repeatable read". Esto se debe a que el procedimiento almacenado debe garantizar que el turno seleccionado no cambie durante el proceso de atención. Por lo tanto, se utiliza este nivel de aislamiento para evitar que se produzcan lecturas sucias y no repetibles. Por ende, si se ejecuta otra transaccion que modifique la tabla de turnos, la otra transaccion se bloqueara hasta que se termine de ejecutar el procedimiento almacenado actual.

* *Aclaraciones y funciones utilizadas*: En el código del procedimiento almacenado "attend_appointment" no se utilizan funciones específicas de PostgreSQL. Sin embargo, hay algunas funciones incorporadas que se mencionan en el código:

1. `now()`: Esta función devuelve la fecha y hora actuales.

2. `::date`: Es un operador de conversión que se utiliza para convertir un valor de tipo "timestamp" en un valor de tipo "date". En el código, se utiliza para convertir la fecha del turno y la fecha actual al tipo "date" y luego se comparan para verificar si coinciden.

===== Cancelar turno
* *Ubicación*: `sql/sp/cancel_appointment.sql`
* *Descripción del proceso*: El SP se basa en que por medio de un for query, recorremos los records resultantes de la union entre aquellos turnos con estado de 'disponible' y 'reservado'. Ademas, al mismo tiempo de obtener dichos turnos, dando uso de un producto cartesiano, filtramos los datos de pacientes y medicos que componen dicho turno,
con el objetivo de insertar mas adelante  dicha información en la tabla de reprogramación. Luego, por cada turno que recorremos, cambiamos su estado a 'cancelado', y en caso de que el turno cancelado sea uno 'reservado', es decir, donde el nro_paciente no sea nulo,  lo insertamos en la tabla de reprogramación.
Finalmente, incrementamos el contador que lleva el conteo de los turnos cancelados. Por último, al terminar la iteración de todos los turnos que satisfagan la condición, retornamos el contador.
* *Isolation level utilizado*: Para este SP se optó utilizar el isolation level de 'Repeateable Read', ya que buscamos evitar que dos personas cancelen turnos al mismo tiempo. Esto va a provocar que una transacción que pretenda cancelar turnos cuando otra ya lo esta haciendo, quede bloqueada
hasta que haya finalizado la ejecución de la primera transacción. Por otro lado, no se opto por el isolation level de 'serializable' ya que en este SP en particular no es crítico el orden en que se ejecutan las transacciones. En consecuencia, ganamos mayor concurrencia y menor overhead gracias a esta decisión.
* *Aclaraciones y funciones utilizadas*: Este SP esta relacionado al trigger de "send_email_on_appointment_canceled" dado que cada vez que se hace un update sobre la tabla de turnos, el mismo se ejecuta  para buscar los turnos cancelados, y manda el aviso de cancelación del turno a cada paciente que haya tenido un turno reservado con el doctor afectado.

===== Generar turnos a partir de un año y mes
* *Ubicación*: `sql/sp/generate_available_appointment.sql`
* *Descripción del proceso*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.
* *Isolation level utilizado*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.
* *Aclaraciones y funciones utilizadas*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.

===== Generar liquidaciones para las obras sociales
* *Ubicación*: `sql/sp/generate_insurance_settlements.sql`
* *Descripción del proceso*: El código del procedimiento almacenado "generate_insurance_settlements" se encarga de generar liquidaciones de las obras sociales. A continuación, se describe su funcionalidad paso a paso:

1. Se declaran las siguientes variables:
- `obraSocial`: Variable de tipo `record` utilizada para almacenar los datos de una obra social específica.
- `turnoRecord`: Variable de tipo `record` utilizada para almacenar los datos de un turno específico.
- `result`: Variable de tipo `record` utilizada para almacenar los datos de resultados de consultas relacionadas a pacientes y médicos.
- `fechaMesLiquidacionHasta`: Variable de tipo `date` que almacena la fecha actual.
- `fechaMesLiquidacionDesde`: Variable de tipo `date` que almacena la fecha del mes anterior a la fecha actual.
- `fechaUltimaLiquidacion`: Variable de tipo `date` que almacenará la fecha de la última liquidación generada.
- `montoObraSocial`: Variable de tipo `decimal` utilizada para calcular el monto total de la liquidación de una obra social.
- `nroLiquidacionActual`: Variable de tipo `integer` utilizada para almacenar el número de liquidación actual.

2. Se verifica si existen registros en la tabla "liquidacion_cabecera". Si hay registros, se obtiene la fecha de la última liquidación generada y se compara con la fecha actual. Si ambas fechas coinciden en año y mes, no se realiza ninguna acción y se finaliza el procedimiento.

3. Se inicia un bucle "for" que itera sobre las obras sociales existentes en la tabla "obra_social".

4. Dentro del bucle, se inicializa el monto de la obra social en $0.

5. Se realiza una inserción en la tabla "liquidacion_cabecera" con los datos correspondientes a la nueva liquidación generada, incluyendo el número de obra social, el rango de fechas de la liquidación y el monto inicialmente establecido como $0.

6. Se obtiene el número de liquidación actual generado en el paso anterior.

7. Se inicia otro bucle "for" que itera sobre los turnos que cumplen las siguientes condiciones:
- El número de obra social del turno coincide con el número de obra social actual del bucle externo.
- El estado del turno es "atendido".
- La fecha del turno está dentro del rango de fechas de la liquidación.

8. Dentro del segundo bucle, se realiza una consulta para obtener los datos del paciente y el médico relacionados con el turno actual. Los resultados se almacenan en la variable `result`.

9. Se realiza una inserción en la tabla "liquidacion_detalle" con los datos correspondientes al turno actual y la liquidación actual. Se incluyen datos como la fecha de atención, número de afiliado, datos del paciente y médico, especialidad y monto correspondiente al seguro médico.

10. Se actualiza el monto de la obra social incrementándolo con el monto del seguro médico del turno actual.

11. Se actualiza el estado del turno a "liquidado".

12. Una vez finalizado el bucle interno, se actualiza el campo "total" de la tabla "liquidacion_cabecera" con el monto total de la obra social correspondiente.

13. Se repiten los pasos 4 a 12 para cada obra social existente en la base de datos.

En resumen, este procedimiento almacenado genera liquidaciones para todas las obras sociales existentes. Recorre los turnos atendidos en un rango de fechas específico y calcula el monto total de la liquidación para cada obra social. Luego, actualiza las tablas "liquidacion_cabecera" y "liquidacion_detalle" con los datos correspondientes.

* *Isolation level utilizado*: Utiliza el nivel de aislamiento "serializable" para aseguramos que no se generen liquidaciones duplicadas ya que las transaccioens se ejecutan secuencialmente, obtenemos un mayor control sobre la lectura de los datos y evitamos que se produzcan errores de concurrencia.

* *Aclaraciones y funciones utilizadas*: El código del procedimiento almacenado "generate_insurance_settlements" utiliza las siguientes funciones específicas de PostgreSQL:

1. `current_date`: Esta función devuelve la fecha actual.

2. `interval`: Es un operador utilizado para calcular una diferencia de tiempo entre dos fechas. En el código, se utiliza para restar un mes a la fecha actual y obtener así la fecha correspondiente al mes anterior.

3. `count()`: Es una función de agregación que cuenta el número de filas que cumplen cierta condición. En el código, se utiliza junto con la cláusula `if` para verificar si existen registros en la tabla "liquidacion_cabecera".

4. `max()`: Esta función devuelve el valor máximo de una columna o expresión. En el código, se utiliza para obtener la fecha de la última liquidación generada.

5. `extract()`: Esta función se utiliza para extraer componentes específicos (como el año o el mes) de una fecha. En el código, se utiliza para comparar los componentes de año y mes entre la fecha de la última liquidación y la fecha actual.

Estas funciones son funciones integradas en PostgreSQL y se utilizan para realizar cálculos, obtener valores de fecha y tiempo, realizar agregaciones y extraer componentes de fecha en el código del procedimiento almacenado.

===== Reservar turno
* *Ubicación*: `sql/sp/reserve_appointment.sql`
* *Descripción del proceso*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.
* *Isolation level utilizado*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.
* *Aclaraciones y funciones utilizadas*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.

===== Enviar emails de turno olvidados
* *Ubicación*: `sql/sp/send_reminder_email.sql`
* *Descripción del proceso*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.
* *Isolation level utilizado*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.
* *Aclaraciones y funciones utilizadas*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.

===== Enviar emails de recordatorios de turnos
* *Ubicación*: `sql/sp/send_reminder_email.sql`
* *Descripción del proceso*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.
* *Isolation level utilizado*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.
* *Aclaraciones y funciones utilizadas*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.

==== Triggers
===== Enviar email de confirmación cuando el turno fue reservado
* *Ubicación*: `sql/triggers/send_confirmation_email_on_appointment_reserved.sql`
* *Descripción del proceso*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.
* *Aclaraciones y funciones utilizadas*: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.

===== Enviar email cuando el turno fue cancelado
* *Ubicación*: `sql/triggers/send_email_on_appointment_canceled.sql`
* *Descripción del proceso*: El trigger "send_email_on_appointment_canceled" se activa después de que se realiza una actualización en la tabla "turno". Su objetivo es enviar un correo electrónico de notificación cuando se cancela un turno. A continuación, se describe su funcionalidad paso a paso:

1. Se declaran las siguientes variables:
   - `result`: Variable de tipo `record` utilizada para almacenar los datos resultantes de una consulta.
   - `email_title`: Variable de tipo `varchar` que almacena el título del correo electrónico.
   - `email_body`: Variable de tipo `varchar` que almacena el cuerpo del correo electrónico.
   - `email_status`: Variable de tipo `varchar` que indica el estado del envío del correo electrónico, establecido como "pendiente".

2. Se verifica si el estado nuevo del turno es igual al estado anterior. Si son iguales, significa que no hubo cambios en el estado y se devuelve el nuevo registro sin realizar ninguna acción adicional.

3. Se verifica si el estado nuevo del turno es "cancelado". Si no lo es, significa que el turno no ha sido cancelado y se devuelve el nuevo registro sin realizar ninguna acción adicional.

4. Se verifica si el estado anterior del turno era "disponible". Si es así, significa que el turno no estaba reservado y, por lo tanto, no se enviará ningún correo electrónico. Se devuelve el nuevo registro sin realizar ninguna acción adicional.

5. Se realiza una consulta para obtener los datos relevantes del turno cancelado, incluyendo el número de turno, el nombre y el correo electrónico del paciente, el nombre del médico y la fecha del turno. Los resultados se almacenan en la variable `result`.

6. Se construye el cuerpo del correo electrónico concatenando los mensajes relevantes con los datos obtenidos de la consulta.

7. Se realiza una inserción en la tabla "envio_email" para almacenar los detalles del correo electrónico a enviar. Se registran la fecha de generación, el correo electrónico del paciente, el asunto del correo electrónico, el cuerpo del correo electrónico y el estado como "pendiente".

8. Se devuelve el nuevo registro del turno.

En resumen, este trigger se encarga de enviar un correo electrónico de notificación cuando se cancela un turno. Realiza una serie de verificaciones y consultas para obtener los datos relevantes y construir el contenido del correo electrónico. Luego, inserta un registro en la tabla "envio_email" y retorna el nuevo registro del turno.

* *Aclaraciones y funciones utilizadas*: El trigger "send_email_on_appointment_canceled" utiliza las siguientes funciones específicas de PostgreSQL:

1. `old`: Es una referencia a la versión anterior del registro afectado por la actualización en la tabla. En el código, se utiliza para acceder a los valores antiguos del estado del turno (`old.estado`).

2. `new`: Es una referencia a la nueva versión del registro afectado por la actualización en la tabla. En el código, se utiliza para acceder a los valores nuevos del estado del turno (`new.estado`).

3. `concat()`: Esta función se utiliza para concatenar cadenas de texto. En el código, se utiliza para construir el cuerpo del correo electrónico uniendo diferentes mensajes y datos.

4. `now()`: Esta función devuelve la fecha y hora actuales.

Estas funciones son específicas de PostgreSQL y se utilizan dentro del trigger para realizar operaciones como obtener los valores antiguos y nuevos de los registros, concatenar cadenas de texto y obtener la fecha y hora actual.

=== NoSQL
==== Descripción
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.

==== Sincronización de NoSQL con SQL
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.

==== Visualización de los datos en la BDD NoSQL
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque tristique ornare euismod. Fusce placerat, enim eu placerat maximus, felis enim interdum nisl, a tempus felis sapien in nisi. In accumsan risus justo, sed egestas ligula hendrerit non. Aliquam ullamcorper iaculis feugiat.

== Conclusiones
El trabajo práctico logró desarrollar un sistema de administración de turnos médicos que cumple con los objetivos establecidos. Se superaron los desafíos encontrados durante el
proceso de desarrollo y se aplicaron soluciones efectivas. El trabajo en equipo y la utilización de herramientas adecuadas contribuyeron a la eficiencia y
calidad del resultado final. Además, el trabajo nos ayudó a comprender como podemos interactuar con la base de datos, no solo con las operaciones convencionales, sino
que tambien con otros elementos como stored procedures, triggers y transactions. Por otra parte, tambien contribuyó a nuestro aprendizaje trabajar tantos con bases
de datos sql y no sql, para tener una mayor noción de sus diferencias y la forma de trabajar cada una.